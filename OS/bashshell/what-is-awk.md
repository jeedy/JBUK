# awk

데이터를 조작하고 리포트를 생성하기 위해 사용하는 언어

### 참고자료
- https://www.tutorialspoint.com/awk/awk_basic_syntax.htm
- https://zzsza.github.io/development/2017/12/20/linux-6/
- https://ra2kstar.tistory.com/153 (중지됨)
- https://recipes4dev.tistory.com/171

awk 형식:
```bash
# filename 에서 pattern 의 line 검색
$ awk 'pattern' filename

# filename 에서 모든 line 마다 {action} 실행
$ awk '{action}' filename

# filename 에서 pattern 의 line 에서 {action} 실행
$ awk 'pattern {action}' filename
```

예시:
```bash
$ cat awkfile
홍 길동 3324    5/11/96 50354
임 꺽정 5246    15/9/66 287650
이 성계 7654    6/20/58 60000
정 약용 8683    9/40/48 365000

$ awk '/길동/' awkfile
> 홍 길동	3324	5/11/96	50354

$ awk '{print $0}' awkfile
>
홍 길동 3324    5/11/96 50354
임 꺽정 5246    15/9/66 287650
이 성계 7654    6/20/58 60000
정 약용 8683    9/40/48 365000

$ awk '{print $1}' awkfile
>
홍
임
이
정

$ awk '/정/{print "\t안녕하세요? " $1, $2 "님!"}' awkfile
>
  안녕하세요? 임 꺽정님!
  안녕하세요? 정 약용님!

$ df | awk '$4 < 100000' 
## |을 이용해 파이프라인 생성 
>
devfs			368       368       0   100%     638          0  100%   /dev
map -hosts	0         0         0   100%       0          0  100%   /net
map auto_home	0         0         0   100%       0          0  100%   /home
```

## awk 동작원리
1. awk는 파일 또는 파이프를 통해 입력 라인을 얻어와 $0라는 내부 변수에 라인을 입력. 각 라인은 레코드라고 부르고, newline에 의해 구분
2. 라인은 공백을 기준으로 각각의 필드나 단어로 나뉜다. 필드는 $1부터 시작. 많게는 100개 이상의 필드를 저장할 수 있음
3. 내장 변수인 FS라고 부르는 필드 분리자가 공백을 할당받는다. 필드가 콜론이나 대시와 같은 문자에 의해 분리되면 새로운 필드 분리자로 FS의 값을 변경할 수 있다
4. awk는 화면에 필드를 출력할 때 print 함수를 사용
5. 콤마는 출력필즈 분리자(OFS)와 매핑되어 있으며 공백을 할당받음


## OFMT 변수
- 숫자를 출력할 때 숫자 포맷 제어할 경우 사용. 간단히 printf를 사용할 수도 있지만, OFMT를 지정할 수 있음.
- default는 %.6g로 소수점 6자리

```bash
$ awk 'BEGIN{OFMT="%.2f"; print 1.23412, 15E-3}'
> 1.23 0.01
```


## printf 함수
- 포매팅된 깔끔한 출력을 할 경우 사용
- newline을 제공하지 않기 때문에 newline이 요구되면 \n을 사용해야함
- c : 문자, d : 10진수, f : 실수, x : 16진수
- -이 붙으면 좌측정렬에서 시작되고 기본형이면 우측정렬에서 시작

## awk -f 옵션
- awk 액션과 명령이 파일에 작성되어 있다면 -f 옵션을 사용

```
awk -f [awk 명령파일] [awk 명령을 적용할 텍스트 파일]
```

awkcommand 파일 생성: 
```
$ vi awkcommand 
  {print "안녕하세요 " $1, $2"님"}
  {print $1, $2, $3, $4, $5}
```

파일 action:
```
$ awk -f awkcommand awkfile
  > 
  안녕하세요 홍 길동님
  홍 길동 3324 5/11/96 50354
  안녕하세요 임 꺽정님
  임 꺽정 5246 15/9/66 287650
  안녕하세요 이 성계님
  이 성계 7654 6/20/58 60000
  안녕하세요 정 약용님
  정 약용 8683 9/40/48 365000
```

## 레코드와 필드

### 레코드 NR
- awk는 입력 데이터를 볼 수 없지만 포맷 또는 구조는 볼 수 있다. 레코드라고 불리는 각 라인은 newline으로 분리
- NR 변수 : 각 레코드들의 번호는 awk의 빌트인 변수 NR에 저장된다. 레코드가 저장된 다음 NR의 값은 하나씩 증가한다

```
$ awk '{print NR, $0}' awkfile
> 
1 홍 길동	3324	5/11/96	50354
2 임 꺽정	5246	15/9/66	287650
3 이 성계	7654	6/20/58	60000
4 정 약용	8683	9/40/48	365000
```

### 필드 NF
- 각 레코드는 디폴트로 공백이나 탭으로 분리된 필드라는 워드로 구성된다. NF에 필드의 수를 유지하며 라인당 100개의 필드를 가질 수 있다

```
$ awk '{print $1, $2, $5,  NF}' awkfile
  > 
  홍 길동 50354 5
  임 꺽정 287650 5
  이 성계 60000 5
  정 약용 365000 5
```

### 필드 분리자 -F
- 빌트인 변수 FS는 입력 필드 분리자의 값을 가지고 있음. default는 공백과 탭. FS 값을 변경하기 위해선 -F을 사용하며 -F 다음에 오는 문자가 새로운 필드 분리자가 됨

```
 $ vi awkfile_FS
  홍 길동 :3324   :5/11/96        :50354
  임 꺽정 :5246   :15/9/66        :283502
```

```
 $ awk -F: '/홍/{print $1, $2}' awkfile_FS
  > 홍 길동	 3324
```

```
$ awk -F'[ :\t]' '/홍/{print $1, $2}' awkfile_FS
  > 홍 길동
```

### 내부변수
변수명 | 내용
--- | ---
FILENAME | 현재 처리중인 파일명
FS | 필드 구분자로 디폴트는 공백
RS | 레코드 구분자로 디폴트는 새로운 라인
NF | 현재 레코드의 필드 개수
NR | 현재 레코드의 번호
OFS | 출력할 때 사용하는 FS
ORS | 출력할 때 사용하는 RS
$0 | 입력 레코드의 전체
$n | 입력 레코드의 n번째 필드


## awk와 정규표현식

## 정규표현식은 슬래시(/)로 둘러싸인 문자들로 구성된 패턴
```
$ awk '/^정/{print $1, $2, $3}' awkfile
> 정 약용 8683

$ awk '/^[A-Z][a-z]+ /' awkfile2
> Hong KilgDong	3324	5/11/96	50354

```



